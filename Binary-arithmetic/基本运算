1. and运算
任何数与1and就等于这个数，因此常用来判断数的奇偶，与1and末尾是1为奇数，为零是偶数。

2 or运算--
两个二进制数，有一个为1结果就为1.
or运算通常用于二进制特定位上的无条件赋值，例如一个数or 1的结果就是把二进制最末位强行变成1。
如果需要把二进制最末位变成0，对这个数or 1之后再减一就可以了，其实际意义就是把这个数强行变成最接近的偶数。

3 xor运算--

如果ab结果不同异或的结果为1，如果ab的结果相同异或的结果为0。因此0和1与1异或结果不变，与1异或结果相当于取反。
xor运算通常用于对二进制的特定一位进行取反操作。
异或的逆运算是自身，也就是说两次异或同一个数之后结果不变。
如果两个运算符为可逆运算符有一个很神奇的性质：比如+与-是可逆运算符，可以写成一个不需要中间变量的交换。、
a = a + b
b = a - b
a = a - b
此时a 与b发生了交换
同理异或也是互逆的运算也有这样很神奇的性质
   a=a xor b;
   b=a xor b;
   a=a xor b;
   
   
4 shl--
a shl b就表示把a转为二进制后左移b位（在后面添b个0）。例如100的二进制为1100100，
换成十进制就是乘以2的b次方
位运算比乘法更快

5 shr--
和shl相似，a shr b表示二进制右移b位（去掉末b位），相当于a除以2的b次方（取整）。
我们也经常用shr 1来代替div 2，比如二分查找、堆的插入操作等等。
想办法用shr代替除法运算可以使程序效率大大提高。最大公约数的二进制算法用除以2操作来代替慢得出奇的mod运算，效率可以提高60%。

    功能              |           示例            |    位运算
———————-+—————————+——————–
去掉最后一位          | (101101->10110)           | x shr 1
在最后加一个0         | (101101->1011010)         | x shl 1
在最后加一个1         | (101101->1011011)         | x shl 1+1
把最后一位变成1       | (101100->101101)          | x or 1
把最后一位变成0       | (101101->101100)          | x or 1-1
最后一位取反          | (101101->101100)          | x xor 1
把右数第k位变成1      | (101001->101101,k=3)      | x or (1 shl (k-1))
把右数第k位变成0      | (101101->101001,k=3)      | x and not (1 shl (k-1))
右数第k位取反         | (101001->101101,k=3)      | x xor (1 shl (k-1))
取末三位              | (1101101->101)            | x and 7
取末k位               | (1101101->1101,k=5)       | x and (1 shl k-1)
取右数第k位           | (1101101->1,k=4)          | x shr (k-1) and 1
把末k位变成1          | (101001->101111,k=4)      | x or (1 shl k-1)
末k位取反             | (101001->100110,k=4)      | x xor (1 shl k-1)
把右边连续的1变成0    | (100101111->100100000)    | x and (x+1)
把右起第一个0变成1    | (100101111->100111111)    | x or (x+1)
把右边连续的0变成1    | (11011000->11011111)      | x or (x-1)
取右边连续的1         | (100101111->1111)         | (x xor (x+1)) shr 1
去掉右起第一个1的左边 | (100101000->1000)         | x and (x xor (x-1))


